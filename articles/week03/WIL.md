# 프론트엔드 미션 트랙 3주차

---

## 쿠키, 토큰, 세션 기본 개념

### HTTP의 특성과 인증의 필요성
* **`HTTP의 한계`**: 무상태와 비연결성 특징 때문에 서버는 클라이언트의 상태를 기억하지 못함
* **`해결책의 진화`**
    * **1단계 Cookie**: 브라우저에 정보를 저장하지만 보안에 취약함
    * **2단계 Session**: 중요 정보는 서버에 저장하고 ID만 쿠키로 주고받지만, 서버 확장성에 한계가 있음

### 토큰 기반 인증과 JWT
* **`JWT (JSON Web Token)`**: 사용자 정보를 암호화하여 클라이언트가 직접 가지고 다니는 `위조 방지 여권` 개념
* **`구조`**:
    * `Header`: 토큰 타입과 해싱 알고리즘 정보
    * `Payload`: 실제 전달할 데이터(Claim)
    * `Signature`: 위변조 방지를 위한 암호화된 서명
* **`보안 전략`**: 탈취 위험을 줄이기 위해 유효기간이 짧은 `Access Token`과 재발급 용도의 `Refresh Token`을 함께 사용함

---

## 비동기 처리의 개념

### 동기 vs 비동기
* **`동기 (Synchronous)`**: 요청 후 응답이 올 때까지 대기하는 직렬적 방식 (순서 보장, 블로킹)
* **`비동기 (Asynchronous)`**: 응답을 기다리지 않고 다음 작업을 수행하는 병렬적 방식 (효율성 증대, 논블로킹)

### 자바스크립트 비동기 제어
* **`Callback`**: 함수의 인자로 함수를 전달하여 실행 순서를 제어하지만, 중첩 시 가독성이 떨어짐(콜백 지옥)
* **`Promise`**: 비동기 작업의 상태(Pending, Fulfilled, Rejected)를 객체로 관리하며 `.then()` 체이닝으로 콜백 지옥 해결
* **`Async/Await`**: Promise를 기반으로 하지만, 코드를 동기적으로 작성하는 것처럼 보이게 하여 가독성을 높인 최신 문법

---

## API 호출 방법 (Fetch vs Axios)

### Fetch API
* **`특징`**: 자바스크립트 내장 함수로 별도 설치가 필요 없음
* **`단점`**: 응답 객체를 받았을 때 `.json()` 메서드를 사용해 JSON으로 변환하는 과정이 필요함
* **`사용법`**: `fetch(url).then(res => res.json()).then(data => ...)`

### Axios
* **`특징`**: 브라우저와 Node.js 호환성이 좋은 외부 라이브러리로, 자동으로 JSON 변환을 지원함
* **`장점`**: 문법이 직관적이고 요청 취소, 타임아웃 설정 등 부가 기능이 풍부함
* **`사용법`**: `axios.get(url).then(res => console.log(res.data))`

---

## API 연동 실습: 유저 목록 조회

### Reqres API 연동 과정
* **`Async/Await` + `Fetch`** 조합을 사용하여 비동기 통신 코드를 구현했습니다.
* **`데이터 구조 파악`**: API 응답 전체가 아닌 `result.data` 배열에 실제 사용자 정보가 있음을 확인하고 해당 부분만 State에 저장했습니다.
* **`UI 구현`**: 불러온 데이터를 `map` 함수를 이용해 카드 형태의 리스트로 화면에 출력했습니다.

---

## 3주차 미션 후기
* 이론으로 배운 Token과 Async/Await를 실제 API 연동 미션을 통해 코드로 구현해보며 개념을 확실히 잡을 수 있었습니다.
* Fetch의 불편함(JSON 수동 변환, 에러 처리 미흡)과 Axios의 편리함(자동 변환, 인터셉터)을 배울 수 있었습니다.
* 가벼운 과제는 Fetch로 빠르게 구현하고, 기능이 복잡하고 유지보수가 중요한 실무 프로젝트에서는 Axios를 도입하면 되겠다는 안목을 기를 수 있었습니다.