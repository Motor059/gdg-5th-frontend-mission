# 프론트엔드 미션 트랙 4주차

---

## 개발 환경의 표준 (ESLint & Prettier)

* **`ESLint (Linter)`**: 코드의 **구현 품질**을 담당하고, 문법 에러나 `const` 사용 강제 등 논리적인 규칙을 검사합니다.
* **`Prettier (Formatter)`**: 코드의 **외형 스타일**을 담당하고, 줄 바꿈과 들여쓰기 등 실행과는 무관한 텍스트 형식을 강제로 통일합니다.
* **`충돌 해결 및 통합`**:
    * 두 도구를 함께 사용하면 포매팅 규칙이 충돌할 수 있습니다.
    * **`plugin:prettier/recommended`** 설정을 통해 ESLint의 포매팅 룰을 끄고, Prettier의 규칙을 ESLint 에러로 통합하여 관리하는 방법을 익혔습니다.
* **`자동화 설정`**: VSCode의 `settings.json`에서 `formatOnSave`(저장 시 포매팅)와 `codeActionsOnSave`(저장 시 린트 수정)를 활성화하여 생산성을 높힐 수 있습니다.

---

## 상태 관리의 핵심

### 상태 관리의 필요성
* **`Prop Drilling 해결`**: 컴포넌트 깊이가 깊어질 때 데이터를 전달하는 번거로움을 해결합니다.
* **`UI와 데이터 동기화`**: 데이터(상태)가 변하면 UI도 자동으로 변하게 하여 유지보수성을 높입니다.

### 라이브러리 선택 기준
* **`Server State`**: API 응답 데이터는 `TanStack Query` 등을 사용해 캐싱과 동기화를 처리합니다.
* **`Client State`**:
    * **`Recoil / Jotai`**: **Atom** 단위로 상태를 쪼개 관리하고,리액트스러운 문법과 동시성 모드 지원이 강점입니다.
    * **`Zustand`**: **Flux 패턴**을 단순화하여 하나의 **중앙 스토어**에서 상태와 액션을 관리하고, 보일러 플레이트가 적어 최근 사용량이 급증하고 있습니다.

---

## 리액트 폴더 구조 전략

* **`초급 구조 (Simple)`**: 파일 종류(`components`, `hooks`)별로 나누는 방식으로 작고 단순한 프로젝트에 적합합니다.
* **`중급 구조 (Page-based)`**: `pages`를 기준으로 하위 폴더를 나누어 라우팅 중심의 설계를 합니다.
* **`고급 구조 (Feature-based)`**:
    * **`Features 폴더`**: 기능(`Todo`, `Auth`)별로 관련된 코드(UI, Hook, API)를 한곳에 모으는 **Colocation(응집도)** 원칙을 적용했습니다.
    * **`Public API`**: 각 기능 폴더의 `index.js`를 통해서만 외부로 코드를 노출하여 의존성을 관리하는 패턴을 익혔습니다.

---

## 4주차 미션 후기
* 이번 주차는 코드를 짜는 것보다 어떻게 짜야 잘 짜는 것인가에 대한 고민을 많이 하게 된 시간이었습니다.
* 특히, ESLint와 Prettier 설정을 자동화했을 때의 쾌적함과 기능별로 폴더를 나눴을 때의 깔끔함을 보며 설계의 중요성을 체감했습니다.
* 상태 관리 라이브러리들이 너무 많아 혼란스러웠지만, 왜 필요한 지와 어떤 상황에 무엇을 써야 할 지에 대한 기준을 잡고 나니 프로젝트 성격에 맞춘 도구를 선택할 수 있는 자신감이 생겼습니다.