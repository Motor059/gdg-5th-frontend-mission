# 상태 관리(State Management) 핵심 개념

---

## 상태란 무엇인가?
- 웹 애플리케이션을 구성하는 **변경 가능한 데이터**이고, UI에 직접적인 영향을 미치는 요소

* **`정의`**
    - **개념적 정의**: 주어진 시간 동안 시스템의 상황을 나타내는 데이터
    - **프론트엔드 정의**: 사용자 인터랙션에 의해 생성되고 수정되고, 최종적으로 **UI(DOM)에 반영되어야 하는 데이터**
    - `예: 카운터 숫자(0 -> 1), 서버에서 받아온 사용자 정보`

* **`관리의 필요성`**
    - **데이터와 UI의 동기화**: 상태가 변하면 UI도 자동으로 변해야 함
    - **Prop Drilling 해결**: 컴포넌트 깊이가 깊어질수록 데이터를 전달하기 힘들어짐 (전역 상태 필요)
    - **불필요한 리렌더링 방지**: 관련 없는 컴포넌트까지 렌더링되는 것을 막아 성능 최적화 필요

---

## 상태 관리 도구 선택 기준
- 무조건 라이브러리를 쓰는 것이 아니라 상태의 특성에 따라 적절한 도구를 선택해야 함

* **`useState / useReducer`**
    - 상태가 **특정 컴포넌트** 안에서만 쓰이거나 간단한 구조일 때 사용
    - `useReducer`는 로직이 복잡할 때 사용

* **`Context API`**
    - 상태가 전역적으로 쓰이지만, **업데이트 빈도가 낮을 때** 사용
    - `예: 테마 설정(Dark Mode), 언어 설정, 로그인한 유저 정보`

* **`Server State (TanStack Query)`**
    - 서버에서 받아오는 데이터(API 응답)를 캐싱하고 동기화할 때 사용
    - `예: 게시글 목록, 상품 리스트`

* **`Client State Library (Zustand, Recoil, Redux)`**
    - 전역적으로 쓰이면서, **업데이트가 빈번하고 복잡한 클라이언트 데이터**일 때 사용
    - `예: 장바구니, 복잡한 폼 데이터`

---

## 주요 상태 관리 라이브러리 비교

### Recoil
- 페이스북에서 만든 리액트 전용 라이브러리로 **원자(Atom)** 단위로 상태를 쪼개서 관리함

* **`특징`**
    - **Atom**: 상태의 최소 단위로 컴포넌트가 구독하면 해당 Atom이 변할 때만 리렌더링됨
    - **Selector**: Atom을 기반으로 파생 데이터를 계산하는 순수 함수 (캐싱 지원)
    - **React Suspense 지원**: 비동기 데이터 처리를 리액트스럽게(선언적으로) 할 수 있음

* **`장단점`**
    - **장점**: `useState`와 문법이 거의 같아 배우기 쉽고, 동시성 모드 호환성이 좋음
    - **단점**: Atom이 전역에 흩어져 있어 의존성 파악이 어려울 수 있음 (아직 실험적 버전 성격이 강함)

### Jotai
- Recoil의 영감을 받아 만들어진 **경량화된 Atomic 라이브러리**

* **`특징`**
    - **Bottom-up 방식**: 작은 Atom들을 조립해서 큰 상태를 만들어 나감
    - **유연한 Atom**: `atomWithStorage` 같은 유틸리티가 내장되어 있음
    - **Minimal API**: Recoil보다 훨씬 가볍고 설정이 단순함

* **`장단점`**
    - **장점**: 불필요한 리렌더링을 막아주는 기능이 강력하고, 번들 사이즈가 매우 작음
    - **단점**: 아직 사용자 수가 경쟁 도구들에 비해 적어 레퍼런스가 부족할 수 있음

### Zustand (관심 라이브러리)
- 독일어로 상태라는 뜻이고, **Redux의 복잡함을 제거한 단순하고 강력한 라이브러리**
- **안정성과 레퍼런스**가 좋고, 현재 가장 성장세가 빨라서 제일 관심이 감 

* **`특징`**
    - **Centralized Store**: 하나의 스토어에 상태와 함수를 모두 정의함 (`create` 함수)
    - **No Provider**: 최상위 컴포넌트를 감쌀 필요가 없어 설치와 적용이 매우 빠름
    - **미들웨어 지원**: `persist`(스토리지 저장), `immer`(불변성 관리) 등을 쉽게 붙일 수 있음

* **`장단점`**
    - **장점**: 러닝 커브가 매우 낮고, 보일러 플레이트가 거의 없으며 컴포넌트 외부에서도 상태 접근 가능
    - **단점**: 앱이 매우 커지면 단일 스토어 파일이 비대해질 수 있어 Top-down, 슬라이스 패턴 등으로 쪼개서 관리해야 함

### Valtio
- **프록시** 객체를 사용하여 상태 변경을 감지하는 **반응형** 라이브러리

* **`특징`**
    - **Mutable한 문법**: `state.count++` 처럼 일반 객체 다루듯 수정하면 알아서 리렌더링됨
    - **Proxy 기반**: 자바스크립트 Proxy API를 사용하여 변경 사항을 투명하게 감지함

* **`장단점`**
    - **장점**: 코드가 직관적이고 반응형 프로그래밍에 익숙하면 매우 편함
    - **단점**: 마법처럼 동작하는 부분이 많아 디버깅이 까다로울 수 있고, 커뮤니티가 가장 작음

---

## 참고 문헌
- https://velog.io/@hyunjine/웹-프론트엔드에서-상태란
- https://yozm.wishket.com/magazine/detail/2233/